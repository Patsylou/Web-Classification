 hankd@ecn.purdue.edu January 1995 here gif ( n K .ps.Z) here [SiN87] any or all [DiO92] [DiC94] [Jor78] wait wait [SiN87] [OKD90] [OKD90a] [CoD94a] [DiO92] i 's bit i wait [Cra93] ( P_PORTBASE P_PORTBASE LPT1: , LPT2: , and LPT3: P_PORTBASE P_PORTBASE P_PORTBASE ( ( [CoD94] [CoD94b] [OKD90a] [OKD90] [DiO92] [CoD94a] iopl() if (iopl(3)) { /* iopl failed, implying we were not priv */ exit(1); } all nice() ioperm() if (ioperm(P_PORTBASE, 3, 1)) { /* like iopl, failure implies we were not priv */ exit(1); } P_PORTBASE if (ioperm(P_PORTBASE, 2, 1)) { /* like iopl, failure implies we were not priv */ exit(1); } inline unsigned int inb(unsigned short port) { unsigned char _v; __asm__ __volatile__ ("inb %w1,%b0" :"=a" (_v) :"d" (port), "0" (0)); return(_v); } inline void outb(unsigned char value, unsigned short port) { __asm__ __volatile__ ("outb %b0,%w1" : /* no outputs */ :"a" (value), "d" (port)); } P_PORTBASE /* To output to P_PORTBASE */ #define P_OUT(x) \ outb(((unsigned char)(x)), \ ((unsigned short) P_PORTBASE)) /* To input from P_PORTBASE+1 */ #define P_IN() \ inb((unsigned short) (P_PORTBASE + 1)) /* To output to P_PORTBASE+2 */ #define P_MODE(x) \ outb(((unsigned char)(x)), \ ((unsigned short) (P_PORTBASE + 2))) P_RDY bit, and not P_INT P_MODE(P_NAK); P_OUT(last_out ^= (P_S0 | P_S1)); last_out P_S0 P_S1 /* Which condition am I waiting for? */ if (last_out P_S0) { /* Waiting for P_RDY */ if ((!(P_IN() P_RDY)) (!(P_IN() P_RDY))) { /* Polled twice, make LED red */ P_OUT(last_out ^= (P_LG | P_LR)); /* Continue waiting */ while (!(P_IN() P_RDY)) CHECKINT; /* Ok, LED green again */ P_OUT(last_out ^= (P_LG | P_LR)); } } else { /* Waiting for not P_RDY */ if ((P_IN() P_RDY) (P_IN() P_RDY)) { /* Polled twice, make LED red */ P_OUT(last_out ^= (P_LG | P_LR)); /* Continue waiting */ while (P_IN() P_RDY) CHECKINT; /* Ok, LED green again */ P_OUT(last_out ^= (P_LG | P_LR)); } } CHECKINT CHECKINT { /* Make P_INT status visible */ P_MODE(P_SEL | P_NAK); /* Check for interrupt */ if (P_IN() P_INT) { /* Process the interrupt.... */ } else { /* Restore P_RDY */ P_MODE(P_NAK); } } P_RDY P_RDY x last_out = ((last_out 0xf0) | x ); nand _ result = P_IN(); nand _ result (( nand _ result 3) 0x0f) ( [BrG94] [BrG94] why Why Why Why Why http://garage.ecn.purdue.edu/~papers/ [BrG94] 8th International Parallel Processing Symposium [CoD94] Dynamic Barrier Architecture For Multi-Mode Fine-Grain Parallelism Using Conventional Processors; Part I: Barrier Architecture, [CoD94a] Dynamic Barrier Architecture For Multi-Mode Fine-Grain Parallelism Using Conventional Processors; Part II: Mode Emulation, [CoD94b] Proc. of 1994 Int'l Conf. on Parallel Processing, [Cra93] Cray T3D System Architecture Overview [DiC94] 7th Annual Workshop on Languages and Compilers for Parallel Computing [DiM94] PAPERS: Purdue's Adapter for Parallel Execution and Rapid Synchronization [DiO92] The Journal of Supercomputing [Jor78] Proc. Int'l Conf. on Parallel Processing [OKD90] Proc. of 1990 Int'l Conf. on Parallel Processing, [OKD90a] Proc. of 1990 Int'l Conf. on Parallel Processing, [SiN87] Proc. of Second Int'l Conf. on Supercomputing, Abstract Keywords Notice for HTML Users 1. Introduction 1.1. Synchronization 1.2. Communication 1.3. Interrupts 2. PC Hardware 2.1. PE Hardware Interface 2.2. PE Port Bit Assignments 3. TTL_PAPERS Hardware 3.1. Barrier/Interrupt Hardware 3.2. Aggregate Communication Hardware 3.3. LED Display Hardware 4. PAPERS Software 4.1. Operating System Interface 4.1.1. Generic UNIX 4.1.2. Linux 4.2. Port Access 4.3. Barrier Interface 4.4. NAND Data Communication 5. Performance 6. Conclusion References Hypertext Index The only 
